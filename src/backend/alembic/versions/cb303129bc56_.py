"""Initial migration: create Config and File tables

Revision ID: cb303129bc56
Revises:
Create Date: 2025-12-22 11:44:57.079785

"""

from typing import Sequence

from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes
from app.models import Config

# revision identifiers, used by Alembic.
revision: str = "cb303129bc56"
down_revision: str | Sequence[str] | None = None
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "config",
        sa.Column(
            "id", sa.Uuid(), server_default=sa.text("(uuidv7())"), nullable=False
        ),
        sa.Column("total_storage_limit_gb", sa.Integer(), nullable=False),
        sa.Column("max_file_size_mb", sa.Integer(), nullable=False),
        sa.Column("default_expiry_days", sa.Integer(), nullable=False),
        sa.Column("default_number_of_downloads", sa.Integer(), nullable=False),
        sa.Column(
            "site_description", sqlmodel.sql.sqltypes.AutoString(), nullable=False
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_table(
        "file",
        sa.Column(
            "id", sa.Uuid(), server_default=sa.text("(uuidv7())"), nullable=False
        ),
        sa.Column("filename", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column("expires_at", sa.DateTime(), nullable=False),
        sa.Column("expire_after_n_download", sa.Integer(), nullable=False),
        sa.Column("download_count", sa.Integer(), nullable=False),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.text("(CURRENT_TIMESTAMP)"),
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###

    # Create Empty table
    config_instance = Config()
    data = config_instance.model_dump(exclude={"id"})
    op.bulk_insert(sa.table("config", *[sa.column(k) for k in data.keys()]), [data])

    #  Enforce Singleton (Prevent multiple rows)
    op.execute("""
        CREATE OR REPLACE FUNCTION enforce_singleton()
        RETURNS trigger AS $$
        BEGIN
            IF (SELECT COUNT(*) FROM config) >= 1 THEN
                RAISE EXCEPTION 'Only one row is allowed in config';
            END IF;
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    """)
    op.execute("""
        CREATE TRIGGER singleton_trigger
        BEFORE INSERT ON config
        FOR EACH ROW
        EXECUTE FUNCTION enforce_singleton();
    """)

    #  Prevent Deletion (Only allow modifications)
    op.execute("""
        CREATE OR REPLACE FUNCTION prevent_config_deletion()
        RETURNS trigger AS $$
        BEGIN
            RAISE EXCEPTION 'The configuration record cannot be deleted';
        END;
        $$ LANGUAGE plpgsql;
    """)
    op.execute("""
        CREATE TRIGGER prevent_deletion_trigger
        BEFORE DELETE ON config
        FOR EACH ROW
        EXECUTE FUNCTION prevent_config_deletion();
    """)


def downgrade() -> None:
    # Drop deletion protection
    op.execute("DROP TRIGGER IF EXISTS prevent_deletion_trigger ON config;")
    op.execute("DROP FUNCTION IF EXISTS prevent_config_deletion();")

    # Drop singleton protection
    op.execute("DROP TRIGGER IF EXISTS singleton_trigger ON config;")
    op.execute("DROP FUNCTION IF EXISTS enforce_singleton();")

    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("file")
    op.drop_table("config")
    # ### end Alembic commands ###
